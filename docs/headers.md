# 1. 头文件

通常每一个 `.cc` 文件都有一个对应的 `.h` 文件. 也有一些常见例外,
如单元测试代码和只包含 `main()` 函数的 `.cc` 文件.

正确使用头文件可令代码在可读性、文件大小和性能上大为改观.

下面的规则将引导你规避使用头文件时的各种陷阱.

## 1.1. Self-contained 头文件 {#self-contained-headers}

``` tag
c
```

> 头文件应该能够自给自足(self-contained)，即可以作为第一个头文件被引入。

为了达到这个要求，一个头文件应该自行引用它需要引用的所有依赖。用户和重构工具不应该需要为它而包含额外的头文件。

不过有一个例外，即一个文件并不是 self-contained 的，而是作为文本插入到代码某处。这些文件就要用 `.inc` 文件扩展名。

如果某函数模板为所有相关模板参数显式实例化，或本身就是某类的一个私有成员，那么它就只能定义在实例化该模板的 `.cc` 文件里。

## 1.2. 头文件保护 {#define-guard}

``` tag
c
```

> 所有头文件都应该有保护来防止头文件被多重包含。

[#pragma once](https://zh.wikipedia.org/zh-hans/Pragma_once) 是一个非标准但是被广泛支持的前置处理符号，会让所在的文件在一个单独的编译单元中只被包含一次。

永远使用 `#pragma once` 而非传统的 `#ifdef` 保护。

**优点：**

`#pragma once` 被所有常用的现代 C++ 编译器所支持。

`#pragma once` 所需的代码更短，书写更简便。当文件被移动时不需修改其内容。

`#ifdef` 可能因为粗心而导致宏名称冲突，进而产生难以发现的错误，而 `#pragma once` 是一种高阶机制，编译器会自动比对档案名称，因此更安全稳定。

**缺点：**

`#pragma once` 是非标准的，使用它可能有编译器兼容性问题。

**结论：**

我们的代码所依赖的编译环境是主流且确定的，不会有过于古老或冷门的编译器使得编译不通过。使用 `#pragma once` 使编写代码更简便且不易出错。

## 1.3. 前置声明 {#forward-declarations}

``` tag
c++ advanced
```

> 尽可能地避免使用前置声明。使用 `#include` 包含需要的头文件即可。

**定义：**

所谓「前置声明」（forward declaration）是类、函数和模板的纯粹声明，没伴随着其定义。

**优点：**

前置声明能够节省编译时间，多余的 `#include` 会迫使编译器展开更多的文件，处理更多的输入。
前置声明能够节省不必要的重新编译的时间。 `#include` 使代码因为头文件中无关的改动而被重新编译多次。

**缺点：**

前置声明隐藏了依赖关系，头文件改动时，用户的代码会跳过必要的重新编译过程。

前置声明可能会被库的后续更改所破坏。前置声明函数或模板有时会妨碍头文件开发者变动其
API. 例如扩大形参类型，加个自带默认参数的模板形参等等。

前置声明来自命名空间 `std::` 的 symbol 时，其行为未定义。

很难判断什么时候该用前置声明，什么时候该用 `#include`
。极端情况下，用前置声明代替 `#include`
甚至都会暗暗地改变代码的含义：

``` c++
// b.h:
struct B {};
struct D : B {};

// good_user.cc:
#include "b.h"
void f(B*);
void f(void*);
void test(D* x) { f(x); }  // calls f(B*)
```

如果 `#include` 被 `B` 和 `D` 的前置声明替代， `test()` 就会调用 `f(void*)`。

前置声明了不少来自头文件的 symbol 时，就会比单单一行的 `include` 冗长。
仅仅为了能前置声明而重构代码（比如用指针成员代替对象成员）会使代码变得更慢更复杂.

**结论：**

尽量避免前置声明那些定义在其他项目中的实体。

至于什么时候包含头文件，参见 [#include 的路径及顺序](#name-and-order-of-includes) 。

## 1.4. 内联函数 (C/C++98前)

``` tag
c
```

> 只有当函数只有 10 行甚至更少时才将其定义为内联函数。

**定义:**

当函数被声明为内联函数之后，编译器倾向于将其内联展开，而不是按通常的函数调用机制进行调用。

**优点:**

只要内联的函数体较小，内联该函数可以令目标代码更加高效。对于存取函数以及其它函数体比较短，性能关键的函数，鼓励使用内联。

**缺点:**

滥用内联将导致程序变得更慢。内联可能使目标代码量或增或减，这取决于内联函数的大小。内联非常短小的存取函数通常会减少代码大小，但内联一个相当大的函数将戏剧性的增加代码大小。现代处理器由于更好的利用了指令缓存，小巧的代码往往执行更快。

## 1.5. 内联函数 (C/C++98后) {#inline-functions}

``` tag
c
```

> 不要将 `inline` 用作内联修饰符，仅在需要在头文件中定义全局函数或全局变量时使用它。

现代编译器在决定是否将函数调用进行内联展开时，已经几乎不参考函数声明中inline修饰符。

inline关键字不仅能修饰函数，也可修饰变量（C++17以后），甚至能修饰命名空间（C++11以后）。
inline更为关键的作用是允许同一个函数或变量的定义出现在多个编译单元之中。

当需要在头文件中定义全局函数或全局变量（未包裹在类中的函数或变量）时，如果有多个编译单元引用了该头文件，就会在链接阶段发生重定义错误。因为每个编译单元都独立编译出了同一个函数或变量。此时若在全局函数或全局变量声明处加上inline修饰，编译器将只会保留其中一个的定义，避免名称冲突。

## 1.6. `#include` 的路径及顺序 {#name-and-order-of-includes}

```tag
c
```

> 使用统一的头文件包含顺序可以增强可读性, 避免隐藏依赖。

**顺序:**

1. 同名头文件（`.cc` 引用同名的 `.h`）
2. C 库
3. C++ 库
4. 其他库的 `.h`
5. 本项目内的 `.h`

避免使用 UNIX 特殊的快捷目录：`.` (当前目录) 或 `..` (上级目录)。使用以 `src` 文件夹为起始的路径。
例如，`google-awesome-project/src/base/logging.h` 应该按如下方式包含：

``` c++
#include "base/logging.h"
```

一个例外是：当`.cc` 引用同名的 `.h` 时，可以不使用完整目录而直接 `#include` 对应的 `.h` 文件。

又如，`dir/foo.cc` 或 `dir/foo_test.cc` 的主要作用是实现或测试
`dir2/foo2.h` 的功能，`foo.cc` 中包含头文件的次序如下:

```
foo2.h (优先位置, 详情如下)
C 系统文件
C++ 系统文件
其他库的 .h 文件
本项目内 .h 文件
```

这种优先的顺序排序保证当 `dir2/foo2.h` 遗漏某些必要的库时， `dir/foo.cc`
或 `dir/foo_test.cc`
的构建会立刻中止。因此这一条规则保证维护这些文件的人们首先看到构建中止的消息而不是维护其他包的人们。

`dir/foo.cc` 和 `dir2/foo2.h` 通常位于同一目录下 (如
`base/basictypes_unittest.cc` 和 `base/basictypes.h`),
但也可以放在不同目录下.

按字母顺序分别对每种类型的头文件进行二次排序是不错的主意。注意较老的代码可不符合这条规则，要在方便的时候改正它们。

您所依赖的符号 (symbols) 被哪些头文件所定义，您就应该包含（include）哪些头文件。
比如您要用到 `bar.h` 中的某个符号，哪怕您所包含的 `foo.h` 已经包含了 `bar.h`, 也照样得包含 `bar.h`, 除非 `foo.h` 有明确说明它会自动向您提供 `bar.h` 中的 symbol。

不过，凡是 `.cc` 文件所对应的「同名头文件」已经包含的，就不用再重复包含进其 cc
文件里面了，就像 `foo.cc` 只包含 `foo.h` 就够了，不用再管后者所包含的其它内容。

举例来说, `google-awesome-project/src/foo/internal/fooserver.cc`
的包含次序如下:

``` c++
#include "fooserver.h" // 优先位置

#include <sys/types.h>
#include <unistd.h>

#include <hash_map>
#include <vector>

#include "base/basictypes.h"
#include "base/commandlineflags.h"
#include "foo/public/bar.h"
```

**例外：**

有时，平台特定（system-specific）代码需要条件编译（conditional
includes），这些代码可以放到其它 includes
之后。当然，您的平台特定代码也要够简练且独立，比如：

``` c++
#include "foo/public/fooserver.h"

#include "base/port.h"  // For LANG_CXX11.

#ifdef LANG_CXX11
#include <initializer_list>
#endif  // LANG_CXX11
```
